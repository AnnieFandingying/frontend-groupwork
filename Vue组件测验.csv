* 题型,* 题干,小题题型,小题题干,正确答案,答案解析,分值,难度系数,知识点,标签,选项数,选项,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x
单选题,在组合式 API 中，watch 函数的作用是：,,,B,"
在组合式 API 里，watch 函数的作用就是监听响应式数据的变化。",1,0,,,4,创建一个计算属性,监听响应式数据的变化,定义一个方法,注册一个组件,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
单选题,Vue 组件的 props 主要用于,,,B,props 是组件之间通信的一种方式，主要用于父组件向子组件传递数据，选项 B 正确。组件内部的数据存储通常使用 data 选项（在选项式 API 中）或响应式变量（在组合式 API 中），选项 A 错误；监听组件外部的事件使用 $emit 和 v-on 等,1,0,,,4,组件内部的数据存储,向子组件传递数据,监听组件外部的事件,定义组件的样式,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
单选题,以下哪个是 Vue 组件的生命周期钩子函数（在组合式 API 中）：,,,D,,1,0,,,4,onMounted(),onUpdated(),onActivated(),以上都是,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
单选题,在 Vue 组件中，emits 选项的作用是：,,,B,emits 选项用于定义组件可以触发的自定义事件，这样可以让组件更加清晰地表明它会触发哪些事件,1,0,,,4,定义组件的 props,定义组件可以触发的事件,定义组件的计算属性,定义组件的样式,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
单选题,在组合式 API 中，reactive 函数可以将以下哪种数据类型转换为响应式数据：,,,D,"
在组合式 API 里，reactive 函数的作用是把一个普通对象转换为响应式数据。
对于对象来说，使用 reactive 函数后，当对象的属性发生变化时，Vue 能够检测到这种变化，并自动更新与之绑定的 DOM 元素。
而数组在 JavaScript 中本质上也是一种特殊的对象，reactive 函数同样可以将其转换为响应式数据。当数组的元素发生变化，比如通过数组的一些方法（如 push、pop、splice 等）修改数组内容时，Vue 也能检测到并进行相应的 DOM 更新。
但是对于基本数据类型（如 number、string 等），reactive 函数并不能直接将其转换为响应式数据 。如果想要让基本数据类型具有响应式，在 Vue 中通常使用 ref 函数。
所以 reactive 函数可以将对象和数组转换为响应式数据，答案选 D 是正确的。",1,0,,,4,基本数据类型（如 number、string）,对象,数组,B 和 C,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
单选题,在 Vue 3 组合式 API 里，若要在组件挂载后执行一段代码，应使用以下哪个函数？,,,B,onMounted 是 Vue 3 组合式 API 中用于在组件挂载后执行代码的生命周期钩子函数。onBeforeMount 是在组件挂载前执行；onBeforeUpdate 是在组件更新前执行；onUpdated 是在组件更新后执行。所以选 B。,1,0,,,4,onBeforeMount,onMounted,onBeforeUpdate,onUpdated,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
单选题,以下关于 Vue 组件的 slot（插槽）说法错误的是：,,,C,插槽不仅可以在父组件中使用，子组件也可以定义插槽来接收父组件传递的内容，实现内容的分发。插槽有默认插槽和具名插槽，具名插槽可以通过 v-slot 指令使用。所以选项 C 说法错误。,1,0,,,4,可以实现组件内容的分发,有默认插槽和具名插槽之分,插槽只能在父组件中使用,具名插槽可以通过 v-slot 指令使用,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
单选题,在 Vue 组件中，使用 v-model 指令绑定表单元素时，实际上是绑定了以下哪两个属性和事件的组合？,,,A,在 Vue 组件中，v-model 指令绑定表单元素时，实际上是 :value 和 @input 的语法糖，即绑定元素的 value 属性并监听 input 事件,1,0,,,4,:value 和 @input,:text 和 @change,:checked 和 @click,:disabled 和 @focus,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
单选题,在 Vue 3 组合式 API 中，shallowRef 和 ref 的主要区别在于？,,,B,"
答案选B是正确的。
背景知识
在Vue 3的组合式API里，ref和shallowRef都是用来创建响应式数据的工具。响应式数据意味着当数据发生变化时，Vue会自动更新与之绑定的DOM元素。
选项A：shallowRef并非只能用于基本数据类型，它也可以用于对象和数组，所以该选项错误。例如可以这样使用shallowRef来处理对象：const obj = shallowRef({name: '张三'}); 。
选项B：shallowRef只对其.value的直接修改才会触发响应式更新，不会深度监听对象内部属性的变化 。而ref会深度监听对象和数组内部的变化。比如对于一个用shallowRef创建的对象const obj = shallowRef({count: 1});，直接修改obj.value.count不会触发响应式更新，只有直接修改obj.value（如obj.value = {newProp: 2} ）才会触发更新；而用ref创建的对象const refObj = ref({count: 1});，当修改refObj.value.count时就会触发响应式更新。所以该选项正确。
选项C：shallowRef由于不需要深度监听，性能通常比ref更好（在不需要深度监听的场景下），所以该选项错误。
选项D：shallowRef是可以在模板中使用的，在模板中使用时通过.value访问其值，所以该选项错误。
综上，shallowRef和ref的主要区别在于shallowRef只有对.value的直接修改才会触发响应式更新，ref会深度监听对象和数组变化，正确答案是B 。",1,0,,,4,shallowRef 只能用于基本数据类型，ref 可用于对象和数组,shallowRef 只有对 .value 的直接修改才会触发响应式更新，ref 会深度监听对象和数组变化,shallowRef 性能比 ref 差,shallowRef 不能在模板中使用,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
单选题,在 Vue 组件中使用具名插槽时，以下哪种写法是正确在父组件中向子组件传递内容到指定具名插槽的？,,,A,"
背景知识
在Vue中，具名插槽是一种将内容分发到子组件特定位置的方式。Vue 2和Vue 3在具名插槽的语法使用上有所不同。
答案解析
选项A：在Vue 3中，使用 # 符号来标识具名插槽是正确的语法。<template #header> 这种写法明确地将 <template> 内的内容分配到名为 header 的具名插槽中。所以选项A的写法在Vue 3里针对向子组件传递内容到指定具名插槽是正确的。

选项B：<template slot=""header""> 这种写法是Vue 2.x版本中使用具名插槽的语法 ，在Vue 3中已经不推荐使用了，所以该选项在Vue 3中不正确。

选项C：<template v-slot:header=""headerData""> 这种写法虽然在Vue 2和Vue 3中都可以用于具名插槽，但是这里多了 =""headerData"" 部分，这一般是用于获取具名插槽作用域的数据，题目只是单纯问向指定具名插槽传递内容的写法，并不涉及获取插槽作用域数据，所以该选项写法不是单纯传递内容到指定具名插槽的正确写法。",1,0,,,4,"<template #header>
  <h1>这是头部内容</h1>
</template>
","<template slot=""header"">
  <h1>这是头部内容</h1>
</template>
","<template v-slot:header=""headerData"">
  <h1>{{ headerData }}</h1>
</template>
",以上写法在 Vue 3 中都正确,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
单选题,在 Vue3 中，若父组件通过provide提供数据，子组件通过inject接收数据，以下哪种说法正确？,,,C,Vue3 的依赖注入机制支持跨层级传递数据，inject可以接收任意祖先组件（包括祖父、曾祖父等）通过provide提供的数据，并非只能接收直接父组件的数据，因此 B 错误，C 正确。provide提供的数据可以是非响应式的（需手动处理响应性），A 错误；provide在祖先组件中使用，inject在后代组件中使用，二者不在同一组件，D 错误。,1,0,,,4,provide提供的数据必须是响应式的,inject只能接收直接父组件提供的数据,inject可以接收任意层级祖先组件提供的数据,provide和inject必须在同一个组件中使用,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
单选题,在 Vue3 的组合式 API 中，若要提供一个响应式数据供后代组件使用，正确的做法是？,,,D,,1,0,,,4,"provide('key', ref(0))，后代用inject('key')接收","provide('key', 0)，后代用inject('key')接收","provide('key', reactive({ count: 0 }))，后代用inject('key').count访问",以上 A 和 C 都正确,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
单选题,"以下代码中，后代组件Child能否正确获取到count并保持响应性？
// 父组件
import { provide, ref } from 'vue'
export default {
  setup() {
    const count = ref(0)
    provide('count', count.value) // 注意这里传递的是count.value
    const add = () => count.value++
    return { add }
  }
}

// 子组件Child
import { inject } from 'vue'
export default {
  setup() {
    const count = inject('count')
    return { count }
  }
}",,,B,父组件中provide传递的是count.value（原始值，非响应式引用），而非count本身（ref对象）。因此子组件inject只能获取到初始值，当父组件调用add修改count.value时，由于传递的不是响应式引用，子组件无法感知变化，不会更新。A 错误，B 正确。代码不会报错，也能获取到初始值，C 和 D 错误。,1,0,,,4,能获取到初始值，且父组件调用add时子组件会更新,能获取到初始值，但父组件调用add时子组件不会更新,无法获取到count，会使用默认值,代码报错，provide不能传递ref.value,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
